# 1. 배열 - 4가지 연산, 정렬된 배열

*배열 == 리스트*

### 4가지 연산

- 읽기 :: 자료 구조 내 특정 위치를 찾아보는 것
  
  - 특정 인덱스에 어떤 값이 들어 있는지 찾는 것.
    
    1. 특정 인덱스마다 메모리 주소를 갖고 있다.
    
    2. 컴퓨터는 모든 메모리 주소에 한 번에 갈 수 있다.
    
    3. 인덱스는 0부터 시작한다. [리스트는 0부터 1, 2, 로 카운트 된다.]

- 검색 :: 자료 구조 내 특정 값을 찾는 것
  
  - 배열에 특정 값이 있는지 알아본 후, 있다면 어떤 인덱스에 있는지 찾는 것.
    
    1. 먼저 읽고
    
    2. 찾는다.
    
    3. 이 때 검색에서의 연산에 사용되는 단계가 많을수록 오래 걸린다.
    
    4. 좀 더 적은 단계로 검색을 하기 위한 방법이 알고리즘.

- 삽입 :: 자료 구조에 새로운 값을 추가하는 것
  
  - 배열의 어딘가에 데이터를 삽입하는 것.
    
    - 보통은 제일 마지막에 추가해준다. append 같은거.
    
    - 처음이나 중간에 삽입하려면 단계가 더 필요하게 된다.

- 삭제 :: 자료 구조에 값을 제거하는 것
  
  - 삽입의 반대
    
    - 효율도 삽입과 비슷하게 든다.

### 정렬된 배열, 이진검색vs선형검색

- 배열과 거의 값지만 값이 순서대로 있어야한다.

> **이진검색**
> 
> 데이터의 절반을 갈라 찾아가는 방법. 

예를들어 1~ 100까지의 배열이 있고 1가지 값을 확인하는 데 1단계가 필요하다고 가정해보자. 

1. 이 때 99의 값을 찾아야한다면 <u>선형검색</u>은 1,2,3 을 앞에서부터 차례로 확인해서 그 값을 찾기 때문에 99를 찾으려면 99단계의 단계가 필요하다.

2. <u>이진검색</u>의 경우엔 일단 50으로 가르고 75, 88, 이런 식으로 계속 반씩을 잘라 찾고자하는 값이 절반보다 크냐 작냐를 비교해서 찾기 때문에 선형검색에 비해 단계수가 적게 소모 된다. 
* 주의할 점은 이진검색은 정렬을 한 후에 가능한 배열 방식이기 때문에 단계를 추가적으로 소모한다. 때문에 찾고자 하는 범위가 적은 경우엔 선형검색이 훨씬 빠를 수 있기에 상황에 맞는 방식을 선택하여야한다.

# 셋(set)

- 집합 자료형 셋(set)의 중요한 두가지 특징
  
  -  중복된 데이터를 저장할 수 없다.
  
  - 순서가 없는 구조의 특성을 갖는다.

- set()를 통해 만들 수 있다. 

- 손쉽게 교집합, 합집합, 차집합을 사용할 수 있다.

```python
s1 = set([1, 2, 3, 4, 5, 6])
s2 = set([4, 5, 6, 7, 8, 9])
s1 & s2             # {4, 5, 6}
s1.intersection(s2) # {4, 5, 6}

s1 | s2             # {1, 2, 3, 4, 5, 6, 7, 8, 9}
s1.union(s2)        # {1, 2, 3, 4, 5, 6, 7, 8, 9}

s1 - s2             # {1, 2, 3}
s2 - s1             # {8, 9, 7}
s1.difference(s2)   # {1, 2, 3}
s2.difference(s1)   # {8, 9, 7}
```



# 빅-오 (시간 복잡도)

- 알고리즘의 시간 복잡도를 나타내는 방법 중 하나. 'Big-O'
  
  ![python] 시간 복잡도와 빅오표기법](https://velog.velcdn.com/images/classe55/post/0380e38d-a6a6-4a85-b726-71c4fa34a111/image.png)

- Big-O 표기법의 종류
  
  - O(1), O(n), O(log n), O(n^2), O(2n)



1. O(1) : 일정한 복잡도(constant complexity)  :  입력 값이 증가해도 시간이 늘어나지 않는다. 입력값의 크기와 관계없이, 출력값을 즉시 얻어낼 수 있다.
   
   - index, indexing, length, appernd, pop, clear

2. O(n)  :  선형 복잡도 ::  비교, 삽입, 삭제, 복사 등등
   
   - 배열과 밀접한 연관

3. O(log n)  :  로그 복잡도(logarithmic complexity), O(1) 다음으로 빠른 시간 복잡도를 가짐.

4. O(n^2)  :  2차 복잡도(quadratic complexity), 입력값이 증가함에 따라 시간이 n의 제곱수의 비율로 증가.
   
   - ex) 이중 for문 처럼 반복문 내에서 반복문이 반복되는 경우 for = n 이라고 보고 n*n이라 n^2의 시간 복잡도를 가짐.

5. O(2n)  :  기하급수적 복잡도(exponential complexity), Big-O 중 가장 느린 시간 복잡도.
   
   -  ex) 재귀로 구하는 피보나치 수열은 재귀를 계속 쓰기 때문에 2n의 시간 복잡도를 가짐.


