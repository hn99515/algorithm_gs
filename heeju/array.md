# 배열

연산(읽기 검색 삽입 삭제)

- Reading
  - 배열은 0부터 인덱싱 
  - 많은 자료를 읽어야 한다면 배열이 제일 빠르다 인덱스에서 요소를 읽어내는 속도는 동일하기 때문에 

- Search
  - 시간이 조금 걸린다. 아이템을 하나하나 체크 해야하기 때문에 빠르진 않다.

- Add
  - insert 혹은 배열에 쓰기
  - 배열 맨끝에 추가(가장 빠른 추가)

- Delete
  - 배열의 마지막 배열 삭제가 가장 빠르게 삭제 가능




정렬된 배열 

- 선형검색: 한개씩 한개씩 검색한다. 데이터가 10개라면 아이템을 찾기까지 10개의 스텝이 필요

  - input size 가 N이라면 N스텝이 요구된다.
  - O(N)을 갖는다.

- 이진 검색 ( binary search)

  - 한번 처리가 진행될때마다 검색해야하는 데이터 처리량이 절반으로 줄어드는 알고리즘
  - 이진검색은 정렬되지 않은 배열에는 사용할 수 없다.
  - 시간복잡도 O(logN)

  

# 집합 set 

- 중복을 허용하지 않는다.
- 순서가 없다(Unordered).
  - 순서가 없기때문에 인덱싱으로 값을 얻을 수 없다. 
  - 인덱싱으로 접근하려면 리스트나 튜플로 변환해줘야함 

```python
s2 = set("Hello")
s2
{'e', 'H', 'l', 'o'}
```



# BigO 표기법

- 알고리즘의 성능을 수학적으로 표현해주는 표기법
- 알고리즘 스피드의 표현법
- 해당 표기법으로 알고리즘의 시간과 공간 복잡도 표현 
- 알고리즘의 실제 러닝 타임을 표시하는것 보다 데이터나 사용자의 증가율에 따른 알고리즘의 성능을 예측하는게 목표 
- 상수와 같은 숫자들은 모두 1이 된다. 



### o(1) 알고리즘

- Constant Time

- 입력 데이터 크기에 상관없이 언제나 일정한 시간이 걸리는 알고리즘
- 언제나 일정한 속도로 결과를 반환한다 



```py
def print_first(arr):
    print(arr[0])

    
# 그러면 이 시간복잡도는 O(2)일까? NO 왜냐하면 BigO는 함수 디테일에 관심없다 그래서 여전히 O(1)
def print_first(arr):
    print(arr[0])
    print(arr[0])
```

-> 여기서 중요한 점 BigO는 상수를 크게 신경 쓰지 않는다. 왜냐하면 큰 원리만 보기 때문에 



### O(N) 알고리즘

- 입력 데이터의 크기에 비례해서 처리시간이 걸리는 알고리즘
- 데이터가 증가함에 따라 비례해서 처리시간이 증가한다. 언제나 같은 비율로 증가/ 그래프 직선/ 선형적 증가 
- 예)선형 검색

```python
# 각 아이템을 다 프린트하는 함수
# 배열 사이즈 10 이면 10번  선형 검색과 비슷 
def print_all(arr):
    for n in arr:
        print(n)
```



### O(N2)

- Quadratic Time

- 이중반복문 생각하면됨! n을 두번!

```py
# 배열이 각 아이템에 대하여 루프를 반복해서 실행

def print_twice(arr):
    for n in arr:
        for x in arr:
            print(x,n)
```

### O(nm)

- n과 m 을 반복 o(n2)와 헷갈릴수있지만 완전 다름. m 이 엄청 크거나 엄청 작은 수 일수 있다. 

### O(N3)

- 3중반복문 N을 3번 / 면적 
- 데이터가 증가함에 따라 더 급격하게 처리시간이 늘어난다 
- O(N2)와 그래프가 유사하다



### O(2N)

- 피보나치 나선형 
- 피보나치 수열 
- O(N2), O(N3) 보다 데이터 증가함에 따라 처리량이 더 많이 늘어난다



### O(MN)

- O(2N)을 나타낼때 2대신 M을 넣어서 나타내면 됨



### O(logN) 

- 대표 알고리즘 binary search 이진검색
  - 한번 처리가 진행될때마다 검색해야하는 데이터 처리량이 절반으로 줄어드는 알고리즘
  - 이전검색은 정렬되지 않은 배열에는 사용할 수 없다.

- O(N)보다 속도가 현저히 빠르고 처리시간이 적게든다. 데이터가 증가해도 성능이 크게 차이나지않는다. 
- 선형시간보다는 빠르지만 상수시간 보다는 느리다.



### O(sqrt(n)) 

- 루트n 



**BigO 를 알게 된다면**

- BigO를 이해하면 알고리즘 분석을 빠르게 할수 있으며, 언제 무엇을 쓸지 빠르기 파악가능, 또한 내 코드 평가가능

  

