# 자료 구조의 중요성

> **자료 구조란 데이터를 조직하는 방법**
> 
> 같은 데이터를 어떻게 다양한 방식으로 조직하는 지가 중요

* 데이터 조직이 코드의 실행 속도에 미치는 영향이 크다.



## ▶ 배열 - 기초 자료 구조

> 배열의 크기 = 배열에 데이터 원소가 얼마나 들어있는지 알려준다.
> 
> 배열의 인덱스 = 특정 데이터가 배열의 어디에 있는지 알려준다.

✔ **자료 구조 연산 4가지**

* **읽기 - 자료 구조 내 특정 위치를 찾는 것** = 배열에서는 특정 인덱스의 값을 찾아보는 것
  
  * 컴퓨터는 모든 메모리 주소에 한 번에 갈 수 있다. = 배열 읽기는 매우 효율적인 연산
  
  * 인덱스는 0부터 시작

* **검색** - 검색은 자료 구조 내에서 특정 값을 찾는 것 = 배열에서는 **특정 값이 배열에 들어 있는지, 만약 들어있다면 어떤 인덱스에 있는지 알아보는 것**
  
  * **읽기와 반대 = 컴퓨터에 값을 제공하고 그 값이 들어있는 인덱스를 반환 요청**
  
  * 검색은 컴퓨터가 특정 값으로 바로 갈 수 없어 시간이 오래 걸림
    
    * 메모리 주소에는 한 번에 접근하지만 각 메모리 주소에 어떤 값이 있는지 바로 알 수 없음 = 읽기보다 덜 효율적

* **삽입 - 자료 구조에서 새로운 값을 추가** = 배열 내 슬롯을 더 만들어 새 값을 추가
  
  * 어디에 데이터를 삽입하는가에 따라 효율성이 다름
  
  * 배열의 맨 처음이나 중간에 삽입하면 데이터를 이동시켜야 하므로 단계가 늘어남
    
    * 최악의 경우 = 맨 처음에 삽입하면 모든 값을 한 셀씩 이동시킴 = N+1 단계

* **삭제 - 자료 구조에서 값을 제거** = 배열 내 값들 중 하나를 제거
  
  * 배열의 첫 번째 원소를 삭제하면 남아 있는 모든 원소를 이동시킴 = N 단계

## ▶ **집합**

> 중복 값을 허용하지 않는 자료 구조

* **집합은 중복 값의 삽입을 절대로 허용하지 않는다❗**

✔ **집합에서의 연산**

- 읽기, 검색, 삭제 - 배열과 동일

- **삽입**
  
  - 삽입할 값이 이미 집합에 들어 있는지 결정해야 함 = **먼저 집합 내 검색이 우선**
    
    - 원소 N개에 대해 최대 2N+1 단계가 필요 = N단계 검색 + N개의 데이터 이동+ 삽입 1단계



# 알고리즘의 중요성

> 단순히 어떤 과제를 완수하는 명령어 집합

✔ 정렬된 배열의 연산

* 값이 항상 순서대로 있어야 한다 = **값을 추가할 때마다 배열의 값을 정렬된 상태로 유지**❗

* 삽입
  
  * 검색을 통한 삽입할 위치 파악
  
  * N + 2 단계 = 전형적인 배열보다 덜 효율적

* 검색
  
  * 찾고자 하는 값보다 검색중이던 값이 크면 검색을 중단 = 찾고자 하는 값이 없음
  
  * 이진 검색(binary search) 사용 가능

## ▶ 이진 검색

> 계속해서 중간 지점을 골라 남은 수 중 반을 제거

* **이진 검색은 정렬된 배열에만 사용 가능‼**

```python
def binary_search(target, data):
    data.sort()
    start = 0
    end = len(data) - 1

    while start <= end:
        mid = (start + end) // 2

        if data[mid] == target:
            return mid
        elif data[mid] < target:
            start = mid + 1
        else:
            end = mid -1

    return None
```

## ▶ 이진 검색 vs 선형 검색

> 데이터를 두 배로 늘릴 때마다 이진 검색 알고리즘에서는 최대 한 단계만 더 추가
> 
> 선형 검색에서는 원소 수만큼의 단계가 필요

* 단, 정렬된 배열이 모든 상황에서 빠른 것은 아니다.
  
  * **정렬된 배열 - 삽입은 다소 느리지만 검색은 훨씬 빠름**

* 모든 상황에 완벽하게 들어맞는 단 하나의 자료 구조나 알고리즘은 거의 없다.



# 빅 오 표기법

> 빅 오 표기법을 사용해 주어진 알고리즘의 효율성을 쉽게 분류

## ▶ 핵심 질문 - 데이터 원소가 N개일 때 알고리즘에 몇 단계가 필요할까?

* O(N)은 알고리즘에 N 단계가 필요하다는 의미
  
  * O(N)은 선형시간을 갖는 알고리즘

* 데이터 원소가 N개일 때 배열의 읽기는?
  
  * O(1) = 상수시간 (가장 빠른 알고리즘 유형)

✔ **빅오의 본질**

* **데이터가 늘어날 때 알고리즘의 성능이 어떻게 바뀌는가❓**

* 빅 오를 통해 어떤 알고리즘이 더 효율적인지 비교하는 것이 중요❗

* 최선, 평균, 최악의 시나리오가 있을 수 있으나 보통은 최악의 시나리오를 두고 비교한다.

## ▶ O(log N)

> log 는 지수와 역의 관계를 의미

* **데이터가 두 배로 증가할 때마다 한 단계씩 늘어나는 알고리즘 = 이진 검색**

* 데이터 원소가 N 개 있을 때 알고리즘에 log N 단계가 걸린다는 의미

* **원소가 하나가 될 때까지 데이터를 계속해서 반으로 줄이는 만큼의 단계 수가 걸림**



✔ 빅 오 확인하기!

```ruby
funcion isLeapYear(year) {
    return (year % 100 == 0) ? (year % 400 === 0) : (year % 4 === 0);
} 주어진 해가 윤년인지 알 수 있는 함수 = O(1)
```

```ruby
function arraySum(arra) {
    let sum = 0;

    for(let i = 0; i < array.length; i++) {
        sum += array[i]
    }
    return sum;
} 주어진 배열의 모든 수를 합하는 함수 = O(n)
```

```ruby
function chessboardSpace(numberOfGrains) {
    let chessboardSpace = 1;
    let placedGrains = 1;

    while (placedGrains < numberOfGrains) {
        placedGrains *= 2;
        chessboardSpaces += 1;
    }
    return chessboardSpaces;
} 복리를 의미하는 함수이며 매 칸마다 2배씩 증가 = O(log n)
```

```ruby
function selectAStrings(array) {
    let newArray = [];

    for(let i = 0; i < array.length; i++) {
        if (array[i]..startsWith('a')) {
            newArray.push(array[i]);
        }
    }
    return newArray;
} 문자열 배열을 받아 'a' 로 시작하는 문자열만 포함시킨 새 배열을 반환 = O(n)
```

```ruby
function median(array) {
    const middle = Math.floor(array.length / 2);
    
    if (array.leength % 2 === 0) {
        return (array[middle - 1] + array[middle]) / 2;
    } else {
        return array[middle];
    }
} 정렬된 배열의 중앙값(median)을 계산하는 함수 = O(1)
```


